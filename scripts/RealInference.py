#!/usr/bin/env python3
import os.path as osp
import os
import sys
import argparse
import json
import time
from datetime import datetime

path = osp.dirname(osp.dirname(osp.abspath(__file__)))

def log_message(msg):
    """Print timestamped log message to stderr"""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"[{timestamp}] {msg}", file=sys.stderr)
    sys.stderr.flush()

def InferAndPrint(video_path, start_frame):
    """
    Mock inference by reading pre-generated inf_frame_N.json files
    and waiting for user to save fin_frame_N.json
    """
    frame_idx = int(start_frame)
    temp_dir = osp.join(path, 'TempAnnoFile')
    
    log_message(f"Starting from frame {frame_idx}")
    log_message(f"Video path: {video_path}")
    
    while True:
        # File paths for current frame
        inf_file_path = osp.join(temp_dir, f'inf_frame_{frame_idx}.json')
        fin_file_path = osp.join(temp_dir, f'fin_frame_{frame_idx}.json')
        
        log_message(f"Checking for inference file: {inf_file_path}")
        
        # Check if mock inference data exists (generated by gen_gt.py)
        if osp.exists(inf_file_path):
            log_message(f"Found inference data for frame {frame_idx}")
            
            try:
                # Load mock inference data
                with open(inf_file_path, 'r') as f:
                    inf_data = json.load(f)
                
                # Send inference results to frontend
                result = {
                    "frame": frame_idx,
                    "predictions": inf_data.get("predictions", []),
                    "status": "inference_ready"
                }
                
                print(json.dumps(result))
                sys.stdout.flush()
                
                log_message(f"Sent inference for frame {frame_idx}, waiting for user annotations...")
                
                # Wait for user to save final annotations
                while not osp.exists(fin_file_path):
                    time.sleep(0.2)  # Check every 200ms
                
                log_message(f"Found user annotations: {fin_file_path}")
                
                # Optional: Read and log user annotations
                try:
                    with open(fin_file_path, 'r') as f:
                        user_data = json.load(f)
                    log_message(f"User saved {len(user_data)} annotations for frame {frame_idx}")
                except:
                    log_message(f"Could not read user annotations for frame {frame_idx}")
                
                # Move to next frame
                frame_idx += 1
                log_message(f"Moving to frame {frame_idx}")
                
            except Exception as e:
                error_msg = {
                    "frame": frame_idx,
                    "status": "error",
                    "error": str(e)
                }
                print(json.dumps(error_msg))
                sys.stdout.flush()
                log_message(f"Error processing frame {frame_idx}: {e}")
                break
        
        else:
            # No more inference files - we've processed all frames
            msg = {
                "frame": frame_idx,
                "status": "completed",
                "message": f"No more frames to process. Completed {frame_idx} frames."
            }
            print(json.dumps(msg))
            sys.stdout.flush()
            log_message(f"No inference file for frame {frame_idx}, inference complete")
            break

def main():
    parser = argparse.ArgumentParser(
        description='Mock inference using pre-generated files'
    )
    parser.add_argument('--video', required=True)
    parser.add_argument('--frame', required=True)
    
    args = parser.parse_args()
    
    try:
        InferAndPrint(args.video, args.frame)
    except KeyboardInterrupt:
        log_message("Process interrupted by user")
        sys.exit(0)
    except Exception as e:
        log_message(f"Fatal error: {e}")
        error_result = {
            "status": "fatal_error",
            "error": str(e)
        }
        print(json.dumps(error_result))
        sys.exit(1)

if __name__ == '__main__':
    main()
